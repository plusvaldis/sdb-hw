# Домашнее задание к занятию 12.8. «Резервное копирование баз данных.» - Черепанов Владислав

---

### Задание 1. Резервное копирование

### Кейс
Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования. 

Необходимо описать, какие варианты резервного копирования подходят в случаях: 

1.1. Необходимо восстанавливать данные в полном объёме за предыдущий день.  
- В данном случае может подойти полный бэкап базы, но в таком случае, требуется большой объем свободного места на носителе, большая нагрузка на сеть и занимает длительное время в зависимости от размера БД.  

- В данном случае может подойти инкрементное резервное копирование, но, есть в этом как плюсы так и минусы, плюсы, занимает меньше места чем полный бэкап, высокая скорость резервного копирования за счет того, что копируются только измененные блоки, а минусы, долго восстановление БД, за счет того что необходимо сначала восстановить полную БД, т.е. начальную точку, а после неё все точки восстановления.  

- В данном случае, так же может подойти дифферециальный бэкап, т.к. имеет относительно не большой размер разностной резервной копии, скорость выполнения выше чем у полного бэкапа а для восстановления требуется полный бэкап и последняя необходимая точка резервного копирования дифф.метода.  

Я бы выбрал в этом случае, всё таки дифф.бэкап, т.к. имеем высокую скорость выполнения бэкапа, и для восстановления базы потребуется только первая точка, и последний блок. Например у меня дифф. полный бэкап делается в выходные в вс, и каждую ночь изменения, и получается что мне для восстановления потребуется полный первый блок и блок за определенный день.  

1.2. Необходимо восстанавливать данные за час до предполагаемой поломки.  
- В данном методе я бы использовал репликацию, например от мастера, передается на слейвы, заранее настроив работу слейва по времени, в случае отказа мастера, можно переназначить один из слейвов и перенаправить всех туда.    
- А так же можно и использовать дифф. бэкап.

1.3.* Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.  

Считаю что возможен, например можно развернуть три ноды, настроить на них репликацию между бд master-slave-slave. в случае отказа мастера, можно переназначить один из слейвов и перенаправить всех туда.  

*настроить vrrp, одна из нод мастер, другая как бэкап, повесть все это на виртуальный адрес, и обращаться к нему, в случае отказа ноды мастера, произойдет переключение на ноду бэкап, но визуально этого не будет видно. т.е. по адресу так как он на виртуальном, либо как вариант можно сделать через pacemaker, в ней контролировать статус mysql например, как только происходит выключение службы(ошибки), автоматом что бы переключал на вторую ноду.


---

### Задание 2. PostgreSQL

2.1. С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).  

Резервирование:  
возможно только одной базы  
pg_dump name_base > /путь/к файлу.dmp  
если критичны данные только в какой то одной таблице, то:  
pg_dump -t table name_base > /путь/к файлу.dmp  
бывают случаи когда используется учетка, отличная от postgres:
pg_dump -U user -W base_name > /путь/к файлу.dmp  
если хотим сделать бэкап всех баз, то:  
pgdumpall > pg_base.bak  

Восстановление:  
pg_restore -U username -d dbname -1 filename.dump

2.1.* Возможно ли автоматизировать этот процесс? Если да, то как?  
Да можно, через скрипт bash, python + cron. А так же через другие системы, такие как тот же забикс, создав скрипт, в забиксе создать триггер со сбором информации с него, который будет запускать скрипт и выполнять, ну и + можно вывести туда информации об выполнении.  

---

### Задание 3. MySQL

3.1. С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL.  

В MySQL мы можем реализовать создание инкрементальных резервных копий с помощью резервного копирования двоичных файлов журнала. Все транзакции, применяемые к серверу MySQL, последовательно записываются в двоичные файлы журнала. Следовательно, всегда можем восстановить исходную базу данных из этих файлов. 

Для реализации такой стратегии нам необходимо прежде всего включить ведение двоичных журналов укажем значение параметров log-bin, expire_log_days, max_binlog_size. каждая инкрементальная копия содержит изменения, которые были созданы с момента последней резервной копии, но самая первая резервная копия должна быть полной копией. необходимо создать полную резервную копию через mysqldump, используя параметры --flush-log и --delete-master-logs, ––delete-master-logs удалит старые двоичные файлы журнала, а --flush-log инициализирует запись нового двоичного файла журнала. Результаты заархивируем.

mysqldump --flush-logs --delete-master-logs --single-transaction --all-databases | gzip > /var/backups/mysql/$(date +%d-%m-%Y_%H-%M-%S)-inc.gz

Мы не можем просто воспользоваться командой cp потому файлы журналов сейчас используются БД. Поэтому необходимо выполнить команду FLUSH BINARY LOGS которая начнет запись в новый двоичный файл журнала в этом случае все накопленные двоичные файлы журнала могут быть безопасно скопированы. После копирования двоичных файлов журнала они должны быть удалены, чтобы при следующем копировании они не дублировали уже созданные резервные копии данных. Для этого воспользуемся PURGE BINARY LOGS.  

#путь к файлу с двоичными журналами
binlogs_path=/var/log/mysql/

#путь к каталогу с бэкапами
backup_folder=/var/backups/mysql/

#создаем новый двоичный журнал
sudo mysql -E --execute='FLUSH BINARY LOGS;' mysql

#получаем список журналов
binlogs=$(sudo mysql -E --execute='SHOW BINARY LOGS;' mysql | grep Log_name | sed -e 's/Log_name://g' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

#берем все, кроме последнего
binlogs_without_Last=`echo "${binlogs}" | head -n -1`

#отдельно последний, который не нужно копировать
binlog_Last=`echo "${binlogs}" | tail -n -1`

#формируем полный путь 
binlogs_fullPath=`echo "${binlogs_without_Last}" | xargs -I % echo $binlogs_path%`

#сжимаем журналы
zip $  backup_folder/  $(date +%d-%m-%Y_%H-%M-%S).zip $binlogs_fullPath

#удаляем сохраненные файлы журналов
echo $binlog_Last | xargs -I % sudo mysql -E --execute='PURGE BINARY LOGS TO "%";' mysql


Можно написать скрипт который все это будет выполнять, а для регулярного использования используем cron.  

Либо настроив репликацию, которые в реальном времени используют инкрементное резервное копирование. 



3.1.* В каких случаях использование реплики будет давать преимущество по сравнению с обычным резервным копированием?  

В случае когда, нужна постоянная работа БД, и её простой, может понести проблемы, например какие нибудь транзакции.

*Приведите ответ в свободной форме.*

---